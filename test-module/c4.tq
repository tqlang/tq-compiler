from Std import {
	Console,
	Process,
	Mem,
	Fs
}

let uint src
let uint debug

let []byte symbols
let []byte text
let []byte data
let []byte stack

let uint srcPointer
let uint currToken
let []uint currIdentifier

@export("main") func main() void {
	
	let argv = Process.getProgramArguments()
	let argc = argv.len as int

	let i = 1
	if ((argc - i) > 0 and argv[i][0] == '-' and argv[i] == "-s") src = i++
	if ((argc - i) > 0 and argv[i][0] == '-' and argv[i] == "-d") debug = i++
	if ((argc - i) < 1) {
		Console.writeln("usage: c4 [-s] [-d] file ...")
		Process.exit(1)
	}

	let file = Fs.open(argv[i])
	let content = Fs.readAllText(argv[i])

	Console.writeln("File content: ___________")
	Console.writeln(content)
	Console.writeln("-------------------------")
	Console.writeln("ok...")

	const uint poolsz = 256 * 1024

	symbols = Mem.alloc(byte, poolsz, Mem.Alignment._1)
	text    = Mem.alloc(byte, poolsz, Mem.Alignment._1)
	data    = Mem.alloc(byte, poolsz, Mem.Alignment._1)
	stack   = Mem.alloc(byte, poolsz, Mem.Alignment._1)

	# No need for memset allocator already does it :p

	let keywords = "char else enum if int return sizeof while " +
				   "open read close printf malloc free memset memcmp exit void main"

	# let idx1 = Tokens._char as uint
	# while idx1 <= Tokens._while as uint : idx1++ do { 
	# 	next()
	# 	currIdentifier[IdentifierOffsets.tk as uint] = idx1
	# }
	# let idx2 = OpCodes.open as uint
	# while idx2 <= OpCodes.exit as uint : idx2++ do {
	# 	next()
	# 	currIdentifier[IdentifierOffsets.class as uint] = idx2
	# }

	Console.writeln("Not bad until here")

}

func next() {
	let uint pp = 0
}

typedef Tokens {
	case num, fun, sys, glo, loc, id, _char, _else, enum, _if, _int, ret, sizeof, _while
	case assign, cond, opLor, opLan, opOr, opXor, opAnd, opEq, opNe, poLt, opGt, opLe, opGe
	case opShl, opShr, opAdd, opSub, opMul, opDiv, opMod, opInc, opDec
	case _break
}

typedef OpCodes {
	case lea,  imm,  jmp,   jsr,   bz,  bnz,  ent,  adj,  lev,   li,   lc,   si,   sc,  psh
	case _or,  xor,  _and,  eq,    ne,  lt,   gt,   le,   ge,    shl,  shr,  add,  sub,  mul,  div,  mod
	case open, read, close, printf, malloc, free, memset, memcmp, exit
}

typedef CTypes {
	case _char
	case _int
	case ptr
}

typedef IdentifierOffsets {
	case tk, hash, name, class, _type, val, hClass, hType, hVal, idsz
}
